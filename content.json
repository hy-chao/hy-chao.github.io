[{"title":"hexo在多台电脑写博客","date":"2017-11-08T14:06:44.000Z","path":"2017/11/08/hexo在多台电脑写博客/","text":"hexo个人博客实现多终端编辑","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"C++运行时类型识别","date":"2017-09-09T07:29:48.000Z","path":"2017/09/09/C-plus-plus运行时类型识别/","text":"运行时类型识别运行时类型识别：通过运行时类型识别（RTTI），程序能够使用基类的指针或引用来检索这些指针或引用所指对象的实际派生类型。 提供RTTI的两个操作符： typeid操作符，返回指针或引用所指对象的实际类型。 dynamic_cast操作符，将基类类型的指针或引用安全的转换为派生类型的指针或引用。 未完待续……","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"堆排序详细分析","date":"2017-06-22T13:49:58.000Z","path":"2017/06/22/堆排序详细分析/","text":"堆排序利用数据结构最大堆和最小堆进行排序操作。升序排序利用最大堆，降序排序利用最小堆。 基本思路（升序为例） 初始化堆：将数列a[1…n]构造成最大堆。 交换数据：将a[1]和a[n]交换，使a[n]是a[1…n]中的最大值；然后将a[1…n-1]重新调整为最大堆。 接着，将a[1]和a[n-1]交换，使a[n-1]是a[1…n-1]中的最大值；然后将a[1…n-2]重新调整为最大值。 依次类推，直到整个数列都是有序的。 数组实现二叉堆有以下性质（第一个数组元素索引值为0）： 索引为i的左孩子的索引是 (2*i+1); 索引为i的左孩子的索引是 (2*i+2); 索引为i的父结点的索引是 floor((i-1)/2); 时间复杂度与稳定性时间复杂度 堆排序的时间复杂度是O(N*lgN)。 堆排序是采用的二叉堆进行排序的，二叉堆就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。最多是多少呢？由于二叉堆是完全二叉树，因此，它的深度最多也不会超过lg(2N)。因此，遍历一趟的时间复杂度是O(N)，而遍历次数介于lg(N+1)和lg(2N)之间；因此得出它的时间复杂度是O(N*lgN)。 稳定性 堆排序是不稳定性算法。在交换数据的时候，是比较父结点和子节点之间的数据，所以，即便是存在两个数值相等的兄弟节点，它们的相对顺序在排序也可能发生变化。 适用情况对较大的序列排序，时间复杂度同快速排序、归并排序，特长所需辅助空间少，适合相对有序的序列排序。 堆排序实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;iostream&gt;using namespace std;//最大堆建堆子步骤（堆的调整）void buildMaxHeap(int *a, int p, int q)&#123; int s = p; int l = 2 * s + 1; int tmp = a[s]; for (; l &lt;= q; s = l, l = 2 * s + 1) &#123; if (l != q &amp;&amp; a[l] &lt; a[l + 1]) &#123; l++; &#125; if (tmp &lt; a[l]) &#123; a[s] = a[l]; a[l] = tmp; &#125; else &#123; break; &#125; &#125;&#125;//堆排序（升序）void heapSortA(int * a, int n)&#123; int tmp; //从最后一个非叶子节点--&gt;0 依次调整，调整结束，数组成为最大堆（建堆）。 for (int i = n / 2 - 1; i &gt;= 0; i--) &#123; buildMaxHeap(a, i, n - 1); &#125; for (int i = n - 1; i &gt; 0; i--) &#123; //交换堆顶元素和堆最后的元素，并将堆的范围缩小1 tmp = a[0]; a[0] = a[i]; a[i] = tmp; //调整剩下的堆元素，使之为最大堆 buildMaxHeap(a, 0, i-1); &#125;&#125;//最小堆建堆子步骤（堆的调整）void buildMinHeap(int *a, int p, int q)&#123; int s = p; int l = 2 * s + 1; int tmp = a[s]; for (; l &lt;= q; s = l, l = 2 * s + 1) &#123; if (l != q &amp;&amp; a[l] &gt; a[l + 1]) &#123; l++; &#125; if (tmp &gt; a[l]) &#123; a[s] = a[l]; a[l] = tmp; &#125; else &#123; break; &#125; &#125;&#125;//堆排序（降序）void heapSortD(int * a, int n)&#123; int tmp; //从最后一个非叶子节点--&gt;0 依次调整，调整结束，数组成为最小堆（建堆）。 for (int i = n / 2 - 1; i &gt;= 0; i--) &#123; buildMinHeap(a, i, n - 1); &#125; for (int i = n - 1; i &gt; 0; i--) &#123; //交换堆顶元素和堆最后的元素，并将堆的范围缩小1 tmp = a[0]; a[0] = a[i]; a[i] = tmp; //调整剩下的堆元素，使之为最小堆 buildMinHeap(a, 0, i - 1); &#125;&#125;int main()&#123; int a[] = &#123; 10, 50, 90, 60, 70, 120, 80, 20, 100, 30, 40 &#125;; int n = 11; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; heapSortA(a, n); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; heapSortD(a, n); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; return 0;&#125; 输出结果：","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"排序算法学习","date":"2017-05-31T06:07:36.000Z","path":"2017/05/31/排序算法学习/","text":"总结排序算法 1、比较排序冒泡排序基本思想：两两比较相邻记录的关键字，如果反序则交换。时间复杂度最好为O(n)，最坏的情况是O(n^2)。空间复杂度O(1), 稳定性算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//升序排列#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//两数交换函数void swap(int &amp;a, int &amp;b)&#123; int tmp = a; a = b; b = tmp;&#125;//基础版void BubbleSort(vector&lt;int&gt; &amp;array)&#123; for(int i = 0; i &lt; array.size(); i++) &#123; for(int j = 1; j &lt; array.size(); j++) &#123; if(array[j-1] &gt; array[j]) &#123; swap(array[j-1], array[j]); &#125; &#125; &#125;&#125;//改进版//思路：记录一轮交换后标记的最后位置，下次从头遍历到这个位置就好。void BubbleSort_v2(vector&lt;int&gt; &amp;array)&#123; int k; int flag = array.size(); while(flag &gt; 0) &#123; k = flag; flag = 0; for(int i = 1; i &lt; k; i++) &#123; if(array[i-1] &gt; array[i]) &#123; swap(array[i-1], array[i]); flag = i; &#125; &#125; &#125;&#125; 直接插入排序基本思想：将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增加1的有序表。时间复杂度为O(n^2)，比冒泡和选择排序的性能要更好一些。 稳定性算法。 123456789101112131415161718#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//直接插入排序void InsertSort( vector&lt;int&gt; array )&#123; int temp; int j; for( int i = 1; i &lt; array.size(); i++ ) &#123; temp = array[i]; for( j = i; j &gt; 0 &amp;&amp; array[j-1] &gt; tmp; j-- ) &#123; array[ j ] = array[ j-1 ]; &#125; array[ j ] = tmp; &#125;&#125; 简单选择排序通过n-i次关键字之间的比较，从n-i+1个记录中选择关键字最小的记录，并和第i（1 &lt;= i&lt;= n）个记录交换值。尽管与冒泡排序同为O（n^2），但简单选择排序的性能要略优于冒泡排序。 稳定性算法。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//两数交换函数void swap(int &amp;a, int &amp;b)&#123; int tmp = a; a = b; b = tmp;&#125;//简单选择排序void simple_select_sort( vector&lt;int&gt; &amp;array )&#123; int min; for(int i = 0; i &lt; array.size(); i++) &#123; min = i; for(int j = i+1; j &lt; array.size(), j++) &#123; if(array[j] &lt; array[min]) &#123; min = j; &#125; &#125; swap(array[i],array[min]); &#125;&#125; 希尔排序先将整个待排元素序列分割成若干个序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序（增量为1）。其时间复杂度为O（n^(3/2) ),要好于直接插入排序的O(n^2)。 不稳定性算法。 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;//希尔排序void shell_Sort( vector&lt;int&gt; &amp;array )&#123; int i, j, increment; int tmp; int N = array.size(); for( increment = N / 2; increment &gt; 0; increment /=2 ) &#123; for( i = increment; i &lt; N; i++ ) &#123; tmp = array[i]; for( j = i; j &gt;= increment; j -= increment ) &#123; if( array[j - increment] &gt; tmp ) &#123; array[j] = array[j - increment]; &#125; else &#123; break; &#125; &#125; array[j] = tmp; &#125; &#125;&#125; 归并排序假设初始序列含有n个记录，则可以看成n个有序的子序列，每个子序列的长度为1，然后两两归并，得到（不小于n/2的最小整数）个长度为2或1的有序子序列，再两两归并，……如此重复，直至得到一个长度为n的有序序列为止。这种排序方法称为2路归并排序。时间复杂度为O（nlogn）,空间复杂度为O（n+logn），如果非递归实现归并，则避免了递归时深度为logn的栈空间，空间复杂度为O(n)。 稳定性算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;using namespace std;/*lpos is the start of left half, rpos is the start of right half*/void merge(int a[], int tmp_array[], int lpos, int rpos, int rightn)&#123; int i, leftn, num_elements, tmpos; leftn = rpos - 1; tmpos = lpos; num_elements = rightn - lpos + 1; /*main loop*/ while (lpos &lt;= leftn &amp;&amp; rpos &lt;= rightn) if (a[lpos] &lt;= a[rpos]) tmp_array[tmpos++] = a[lpos++]; else tmp_array[tmpos++] = a[rpos++]; while (lpos &lt;= leftn) /*copy rest of the first part*/ tmp_array[tmpos++] = a[lpos++]; while (rpos &lt;= rightn) /*copy rest of the second part*/ tmp_array[tmpos++] = a[rpos++]; /*copy array back*/ for (i = 0; i &lt; num_elements; i++, rightn--) a[rightn] = tmp_array[rightn];&#125;void msort(int a[], int tmp_array[], int left, int right)&#123; int center; if (left &lt; right) &#123; center = (right + left) / 2; msort(a, tmp_array, left, center); msort(a, tmp_array, center + 1, right); merge(a, tmp_array, left, center + 1, right); &#125;&#125;void merge_sort(int a[], int n)&#123; int *tmp_array; tmp_array = (int *)malloc(n * sizeof(int)); if (tmp_array != NULL) &#123; msort(a, tmp_array, 0, n - 1); free(tmp_array); &#125; else printf(\"No space for tmp array!\\n\");&#125; 堆排序 堆是具有下列性质的完全二叉树：每个节点的值都大于或等于其左右孩子节点的值，称为大顶堆；或者每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆。 堆排序就是利用堆进行排序的方法。基本思想是：将待排序的序列构造成一个大顶堆.此时,整个序列的最大值就是堆顶的根结点.将它移走(其实就是将其与堆数组的末尾元素交换,此时末尾元素就是最大值),然后将剩余的n-1个序列重新构造成一个堆,这样就会得到n个元素的次大值.如此反复执行,便能得到一个有序序列了。时间复杂度为O(nlogn),好于冒泡,简单选择,直接插入的O(n^2)。 不稳定性算法。 123456789101112131415161718192021222324252627282930313233343536373839// 构造大顶堆#define leftChild(i) (2*(i) + 1)void percDown(int *arr, int i, int N)&#123; int tmp, child; for (tmp = arr[i]; leftChild(i) &lt; N; i = child) &#123; child = leftChild(i); if (child != N - 1 &amp;&amp; arr[child + 1] &gt; arr[child]) child++; if (arr[child] &gt; tmp) arr[i] = arr[child]; else break; &#125; arr[i] = tmp;&#125;void HeapSort(int *arr, int N)&#123; int i; for (i = N / 2; i &gt;= 0; i--) percDown(arr, i, N); for (i = N - 1; i &gt; 0; i--) &#123; swap1(&amp;arr[0], &amp;arr[i]); percDown(arr, 0, i); &#125;&#125;int main(void)&#123; int arr[] = &#123; 9, 2, 5, 8, 3, 4, 7, 1, 6, 10&#125;; HeapSort(arr, 10); for (int i = 0; i &lt; 10; i++) cout &lt;&lt; arr[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 0;&#125; 快速排序对于包含n个数的输入数组，快速排序是一种最坏情况时间复杂度为O(n^2)的排序算法。虽然最坏情况时间复杂度很差，但是快速排序通常是实际排序应用中最好的选择，因为它的平均性能非常好：它的期望时间复杂度为O(nlogn)，而且O(nlogn)中隐含的常数因子非常小。其思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 不稳定性算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void swap(int &amp;a, int &amp;b)&#123; int tmp; tmp = a; a = b; b = tmp;&#125;int partition(vector&lt;int&gt; &amp;a, int p, int r)&#123; int x = a[r]; int i = p - 1; for (int j = p; j &lt; r; j++) &#123; if (a[j] &lt;= x) &#123; i++; if(i == j) continue; swap(a[i], a[j]); &#125; &#125; swap(a[i + 1], a[r]); return i + 1;&#125;void quickSort(vector&lt;int&gt; &amp;a, int p, int r) //初始调用为quickSort（a, 0, a.size()-1）&#123; int q; if (p &lt; r) &#123; q = partition(a, p, r); quickSort(a, p, q-1); quickSort(a, q+1, r); &#125;&#125;int main()&#123; vector&lt;int&gt; a = &#123; 1, 4, 2, 6, 7, 8, 4, 2, 76, 98, 2, 4, 9, 54, 89, 12 &#125;; int r = a.size() - 1; quickSort(a, 0, r); for (int i = 0; i &lt; a.size(); i++) &#123; cout &lt;&lt; a[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; getchar(); return 0;&#125; 2、非比较排序 非比较排序理论上可以达到O(n),快于比较排序，但是下面三种都是有其应用背景才能发挥作用的，否则使得其反。 计数排序计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。步骤如下： 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的位置为1的元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1； 由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。 桶排序桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。 排序的过程如下： 设置一个定量的数组当作空桶子。 寻访串行，并且把项目一个一个放到对应的桶子去。（hash） 对每个不是空的桶子进行排序。 从不是空的桶子里把项目再放回原来的串行中。 基数排序基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 实现：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。注意，这里必须使用稳定排序，否则，就会让原先的地位排序成果毁于一旦，最终的不到正确的排序结果。 基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。 3、排序算法的稳定性算法稳定性概念：考察排序算法的时候有一个很重要的特性，就是算法的稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。 算法稳定性的意义 在实际的应用中，我们交换的不一定只是一个整数，而可能是一个很大的对象，交换元素存在一定的开销； 不稳定排序是无法完成基数排序。 4、排序算法的选择 若n较小(如n≤50)，可采用直接插入或直接选择排序。当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。 若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜。 若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。 快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短； 堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的； 若要求排序稳定，则可选用归并排序。但从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子文件，然后再两两归并之。因为直接插入排序是稳定 的，所以改进后的归并排序仍是稳定的。","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"C_plus_plus学习","date":"2017-04-12T11:43:23.000Z","path":"2017/04/12/C-plus-plus学习/","text":"心之所向 素履以往 生如逆旅 一苇以航 ​ ——七堇年 《尘曲》 柔性数组 char data[0]或char data[] 称为柔性数组,只能放在结构体末尾。 作用: 方便管理内存缓冲区 减少内存碎片化 C++虚函数实现机制 虚函数的作用 简单的讲即实现多态。基类定义了虚函数，子类可以重写该函数，当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态地调用属于子类的该函数，且这样的函数调用是无法在编译器期间确认的，而是在运行时期确认，也叫作迟绑定。C++对象模型 这个模型从结合上面2中模型的特点，并对内存存取和空间进行了优化。在此模型中，non static 数据成员被放置到对象内部，static数据成员， static and nonstatic 函数成员均被放到对象之外。对于虚函 的支持则分两步完成： 每个class产生一堆指向虚函数的指针，放在表格之中。这个表格称之为虚函数表（virtual table，vtbl）。 每一个对象被添加了一个指针，指向相关的虚函数表vtbl。通常这个指针被称为vptr。vptr的设定（setting）和重置（resetting）都由每一个class的构造函数，析构函数和拷贝赋值运算符自动完成。 另外，虚函数表地址的前面设置了一个指向type_info的指针，RTTI（Run Time Type Identification）运行时类型识别是有编译器在编译器生成的特殊类型信息，包括对象继承关系，对象本身的描述，RTTI是为多态而生成的信息，所以只有具有虚函数的对象在会生成。 Const关键字的使用方法 学习地址 static关键字的使用方法 学习地址 extern关键字的使用方法 学习地址 运算符重载的规则 不可以引入新的运算符。除了. .* :: ?: 四个运算符，其他的运算符都可以被重载。 运算符的操作数目不可以改变。 运算符的优先级不可以改变。 运算符函数的参数列中，必须至少有一个参数为class型别。无法为诸如指针之类的non-class型别重新定义其原有的运算符，当然也无法为它引入新运算符。 位域 一种特殊的数据成员，来保存特定的位数。当程序需要将二进制数据传递给另一个程序或硬件设备的时候，通常使用位域。（位域在内存中的布局是机器相关的） 位域必须是整型数据类型，可以是signed或unsigned。通过在成员名后面接一个冒号以及指定位数的常量表达式，指出成员是一个位域： 1234567typedef unsigned int Bit;class File&#123; Bit mode: 2; Bit modified: 3; //...&#125;; 通常最好将位域设为unsigned类型。存储在signed类型中的位域的行为由实现定义。 位域的访问方式与类的其他成员相同。例如作为类的private成员的位域只能从成员函数的定义和类的友元中访问： 12345678910void File::write()&#123; modified = 1; //...&#125;void File::close()&#123; if(modified) //...save content&#125; 通常使用内置按位操作符操纵超过一位的位域： 1234567enum&#123; READ = 01, WRITE = 02 &#125;;int mian()&#123; File myFile; myFile.mode |= READ; //set the READ bit //...&#125; 地址操作符（&amp;）不能应用于位域，所以不可能有引用类位域的指针，位域也不能是类的静态成员。 volatile限定符 直接处理硬件的程序常具有这样的数据成员，它们的值由程序本身直接控制以外的过程所控制。应该将这种对象的值声明为volatile。关键字volatile是给编译器的指示，指出对这样的对象不应该执行优化。 链接指示：extern “C” 声明非C++函数 链接指示有两种形式：单个的或复合的。链接指示不能出现在类定义或函数定义的内部，它必须出现在函数的一次声明上。 123456extern &quot;C&quot; size_t strlen(const char*);extern &quot;C&quot; &#123; int strcmp(const char*, const char*); char *strcat(char *, const char*);&#125; ​ 链接指示与头文件 可以将多重声明形式应用与整个头文件。 123extern &quot;C&quot;&#123; #include&lt;srting.h&gt;&#125; 当将#include指示放在复合链接指示的花括号中的时候，假定头文件中的所有普通函数声明都是用链接指示的语言编写的函数。 导出C++函数到其他语言 通过对函数定义使用链接指示，使得其他语言编写的程序可以使用C++函数： 12extern &quot;C&quot; double calc(double dparm) &#123;/* ... */&#125; 当编译器为该函数产生代码的时候，它将产生适合于指定语言的代码。 链接指示支持的语言 要求编译器支持对C语言的链接指示。编译器可以为其他语言提供链接说明。（支持什么语言随编译器而变。你必须查阅用户指南，获得关于编译器可以提供的任意非C链接说明的进一步信息） 重载函数与链接指示 链接指示与函数重载之间的相互作用依赖于目标语言。如果语言支持重载函数，则为该语言实现链接指示的编译器很可能也支持C++的这些函数的重载。 C++保证支持的唯一语言是C。C语言不支持函数重载，所以，在一组重载函数中只能为一个C函数指定链接指示。用带给定名字的C链接声明多于一个函数是错误的。 在C++程序中，重载C函数很常见，但是，重载集合中的其他函数必须都是C++函数。 extern “C” 函数的指针 编写函数所用的语言是函数类型的一部分。为了声明用其他程序设计语言编写的函数的指针，必须使用链接指示： 1extern &quot;C&quot; void (*pf) (int); 使用pf调用函数的时候，假定该调用是一个C函数调用而编译该函数。 C函数的指针与C++函数的指针具有不同的类型，不能将C函数的指针初始化或赋值为C++函数指针（反之亦然） 应用与整个声明的链接指示 使用链接指示的时候，它应用于函数和任何函数指针，作为返回类型或形参类型使用： 1extern &quot;C&quot; void f1(void(*) (int)); 因为链接指示应用于一个声明中的所以函数，所以必须使用类型别名，以便将C函数的指针传递给C++函数： 12extern &quot;C&quot; typedef void FC(int);void f2(FC *); ​","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Hello World","date":"2016-12-31T22:06:06.000Z","path":"2017/01/01/hello-world/","text":"hexo简单命令行 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]